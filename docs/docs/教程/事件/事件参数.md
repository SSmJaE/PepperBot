## 任意参数的可能性

在实际使用中，经常会遇到这样的情况，定义方法/函数时，定义了很多参数，但是实际只使用到其中几个，在定义事件回调时，这种情况更是常见

有没有办法按需取用呢？也就是，只定义自己需要用到的参数，用不到的参数，就不出现在方法的定义中了

通过\*args 与\*\*kwargs，可以将不需要的参数收纳到 args 和 kwargs 这两个动态参数中，但是使用时，我们需要为每一个函数都写一次，而且看起来并不优雅

通过 python 的元编程手段，我们可以优雅的做到这一点

:::info
如果你使用过 JavaScript 的对象解构语法，可能会对这有点眼熟，其实可以把这理解为，无法自动推导类型的，通过关键字参数模拟的对象解构
:::

## 如何实现任意参数

这一部分涉及技术细节，完全可以跳过，如果你对实现任意参数比较感兴趣，可以看一下这部分

通过 inspect 包，以及**annotation**，**code**等 dunder，我们可以获取到方法/函数定义的参数，以及他们的类型

```py3
[args, varargs, varkw] = inspect.getargs(method.__code__)
```

因此我们可以通过参数名，判断具体定义了哪些参数，按需传入

参数的动态传入，可以查看[fit_kwargs 函数](https://github.com/SSmJaE/PepperBot/blob/master/pepperbot/utils/common.py)

通过参数的类型，我们甚至可以判断参数的类型是否合法/有效，将问题在初始化解决扼杀

参数类型的检测，可以查看[cache 函数](https://github.com/SSmJaE/PepperBot/blob/master/pepperbot/parse/cache.py)

:::warning
PepperBot 是完全类型提示的，所以我们也建议开发者使用完全的类型提示

表现在事件响应的定义上，所有参数也需要提供类型注解，且类型注解需要与对应的类型一致
:::

:::info
类型提示保证使用的正确

vscode 配合 pylance 插件，或者 pycharm，都对 python 的类型注解有着不错的支持
:::

## 可以使用的参数

根据我们在事件响应中提到的，我们可以通过事件名来定义事件回调，那么每个事件回调可用的参数有哪些呢？

[这份文件](https://github.com/SSmJaE/PepperBot/blob/master/pepperbot/parse/kwargs.py#L62)列举了事件名和其对应的参数，以及该参数的类型，接下来我们通过实例说明如何使用

其中 key 为事件名，value 为参数列表

注意，所有事件都有一个 event 参数，类型是 Dict 或者 Dict[str, Any]，event 参数是一个字典，保存了当前的原始事件，

因为所有事件响应中，这个参数的名称和类型都完全一致，所以没有在这里列出，而是之后一起注入的

## 实际使用

比如我们定义一个群消息事件响应

根据[这份文件](https://github.com/SSmJaE/PepperBot/blob/master/pepperbot/parse/kwargs.py#L62)，我们可以发现这段代码

```py3
GroupEvent.group_message: [
   EventHandlerKwarg(name="bot", type=GroupCommonBot, value=construct_GroupCommonBot),
   EventHandlerKwarg(
        name="sender",
        type=Sender,
        value=lambda event, **kwargs: construct_sender(event),
    ),
   EventHandlerKwarg(
        name="chain",
        type=MessageChain,
        value=lambda event, **kwargs: construct_chain(
            event, groupId=event["group_id"]
        ),
    ),
    ],
```

可以看到，group_message 事件，也就是群消息事件，有三个参数，他们的名字是 bot, sender, chain, 对应的类型时 GroupCommonBot, Sender, MessageChain，还有一个 Dict 类型的 event

作为框架的使用者，我们可以不用理会实例化 HandlerKwarg 这个 class 时的 value 参数，这是动态组合参数的实现

bot 参数是 GroupCommonBot 类型，其上绑定了许多群消息相关的方法，比如发送群消息的 bot.group_msg 方法，

chain 是 MessageChain 类型，也就是消息链，我们会在消息链部分单独讲解

sender 即为发送当前消息的群成员，其上绑定了 sender.kickout，sender.ban 等常用操作

现在，我们可以按照我们的需要来定义时间相应的参数了

### 所有参数

```py3
class WhateverNameYouWant:

    async def group_message(self, bot: GroupCommonBot, chain: MessageChain, sender: Sender, event:Dict):
        pass

```

这里，我们将所有的参数都定义了，当其实一般用不到所有的参数

:::info
除了 self 必须是第一个以外，参数的顺序是无所谓的
:::

### 部分参数

```py3
class WhateverNameYouWant:

    async def group_message(self, bot: GroupCommonBot):
        pass

```

这里，我们只定义了 bot 参数，可以调用 bot 上的 group_msg 方法，其它参数我们也许用不到，也就完全可以不定义了

## 参数的类型

上文提到过，PepperBot 是完全类型提示的，我们也建议开发者使用类型注解

所以如果出现这样的定义

```py3
class WhateverNameYouWant:

    async def group_message(self, bot, chain,):
        pass
```

在 PepperBot 初始化时，就会出现友好的报错

```
群消息事件响应.py中的类响应器WhateverNameYouWant的group_message事件的参数bot未提供类型注解，其类型
为<class 'pepperbot.parse.bots.GroupCommonBot'>
```

pepperbot.parse.bots.GroupCommonBot，提示了该类型的导入路径

如果类型错误，如

```py3
async def group_message(self, bot:int, chain,):
        pass
```

则会提示

```
群消息事件响应.py中的类响应器WhateverNameYouWant的
group_message事件的参数bot的类型应该为<class 'pepperbot.parse.bots.GroupCommonBot'>，而不是<class 'int'>
```

## 不存在的参数

```py3
async def group_message(self, bottt,):
        pass
```

如果参数名不存在与该事件可用的参数中，则会提示

```
群消息事件响应.py中的类响应器WhateverNameYouWant的group_message事件不存在参数bottt
可用的参数及类型有bot: <class 'pepperbot.parse.bots.GroupCommonBot'>, sender: <class 'pepperbot.models.sender.Sender'>, chain: <class 'pepperbot.message.chain.MessageChain'>, event: typing.Union[dict, typing.Dict, typing.Dict[str, typing.Any]]
```

`raw_event: typing.Union[dict, typing.Dict, typing.Dict[str, typing.Any]`

这里看到了一长串 type hints，不用害怕，这是 Union type，我们只需要从中选择一种即可

比如`raw_event : dict`
