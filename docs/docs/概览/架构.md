# 用户流程

## 用户注册平台适配器
- 所有平台都是一个端口
- 不同平台的path不一样
- 可以设置是ws方式还是http方式

<!-- ## 用户注册插件
- 插件，同时修改配置
  - 比如日志
  - 配置项是可选的，如果不传，采用默认值
  - 插件配置都继承ConfigBase，register_plugin()的第二个参数，config的类型就是这个
- 内置插件
  - 内置插件，名义上叫插件，其实是框架的一部分，之所以也称为插件，因为他们相对于最核心的接受和返回消息来说，确实算是额外功能；
  - 并且这些功能，希望可以被配置；
  - 另外，把这些相对不那么核心的功能独立出来，目录结构会更清晰
  - 内建插件的对象是要可以导出的，比如logger，scheduler，所以不提供register，因为框架内部要使用，放在用户侧注册，会导致冲突
  - 要修改配置的话，用update，不用再手动register，因为框架本身已经在使用了，所以只提供和普通插件一样的update接口用于修改配置 -->

## 用户注册路由
- 插件就是一系列行为的集合，由函数响应器或者类响应器组合而成
- 用户的也是由这两者组成
- 路由中设置转发
  - 这些是多对多的关系
  - 可以用django式的集中路由，也可以用flask风格的装饰器，最终解析出的meta都是一样的
  - 哪些响应器对应哪些平台，哪些群
    - 动态、静态的群过滤
  - 需要哪些指令，应用到哪些群和响应器上

## 用户其它行为
- 比如注册定时任务等

## 启动框架

# 框架流程

## 解析路由，缓存
- 根据注册的路由，先缓存所有的函数、类响应器，把他们映射到不同的事件上
- 缓存平台、群号、响应器、指令的对应关系
- 缓存不同平台机器人自身信息，如果协议有接口的话

## 有新事件时
- 根据缓存的解析出来的映射关系，调用事件对应的响应器
  - 如果有hook的话，比如pre、post之类，按顺序调用即可
- 群消息事件时，调用指令(可以做到poke之后响应指令，也就是说，非文字消息，不过没太大必要)

## 定时任务
- 指令超时定时检查
- 用户定义的定时任务

## 主动行为
- 获取群文件、成员列表之类比较大的文件时，缓存至sqlite
- 可以refresh=True，强制重新获取，而不使用缓存

# 跨平台实现

## 事件响应/转发机制
- 先看是否是PepperBot的通用事件
  - group_message
  - 通用事件，就是将不同平台的接口统一了
- 如果不是，查看是否是各个平台的对应事件
  - onebot_something
  - keaimao_something
  - 平台独立事件，即使事件名称可能相似，但是接口一般是不一样的
- 如果都没有，报错——无效事件

## api调用/转发机制
- 通用api，一致的接口，内部会自动转化为不同协议的格式
  - 通用api内部，调用的其实就是平台独立api，也可以直接调用
- 平台独立api