---
title: 交互策略
---

指令的交互策略是指什么呢？

直觉上来说，指令肯定是针对某一个用户的吧？

比如群中有两个用户A、B，A如果触发了指令，那么这个指令肯定是针对于A的

后续A继续与指令进行交互，会话状态也是一直维持在A身上的，没有B的事

如果A、B同时触发了同一个指令，A、B的指令的状态，也是各自独立的，互不干扰

大部分情况下，这种锁定策略就是我们想要的，不过，`PepperBot`也提供了其他的交互策略

## 有哪些交互策略

我们在上方讨论的交互策略，可以总结为，“在同一个群中，锁定同一个用户”

包含这种交互策略在内，`PepperBot`一共提供了4种

|配置项|解释|
| --- | ---|
| same_source_same_user| 相同来源，相同用户|
| same_source_any_user| 相同来源，任意用户|
| any_source_same_user| 任意来源，相同用户|
| any_source_any_user| 任意来源，任意用户 |

## 消息来源的定义

来源(source)是指什么？`PepperBot`是一个跨社交平台的框架，像QQ，消息来源可以分为群，或者私聊

对于Discord、QQ频道来说，则提供了频道这样一种消息来源

所以我们可以总结一下，消息来源可以是这几种

|配置项|解释|
|---|---|
|private| 私聊消息|
|group| 群聊消息|
|channel| 频道消息|

相同来源、不同来源又是指什么呢？

假设我们现在在一个群中，那么，来自该群任意用户的消息，我们都认为是同一个消息来源，即该群

配合对用户的锁定，现在我们能实现非常灵活的指令效果

这几种交互策略，都提供了以“复读”为功能的指令实现，可以注册到路由中，用一下，看看实际效果

### 全局锁定用户

> any_source_same_user

比如，我希望全局锁定同一个用户，不管他是在哪个群中触发了指令，也不管他是通过群聊还是私聊，只要是他，那就可以继续指令的会话

比如，用户可以在A群发一条消息，然后在B群发一条消息，再直接私聊机器人，发送一条消息

对于锁定用户的指令来说，这些消息都是连续的

对于一些有次数限制的指令来说，非常适合这种交互策略，避免了手动锁定用户的繁琐步骤

可以参考[锁定用户复读]这个指令的实现

### 全群参与的指令

> same_source_any_user

偶尔有些场景，我们希望整个群的成员，都能够参与进来

比如有一个成语接龙，当触发(激活)该指令后，我希望任意用户都能继续会话，这时候，我们就可以设置为“相同来源，任意用户”

可以参考[全群复读]这个指令的实现

### 每个群的交互独立

> same_source_same_user

如果设置为“相同来源，相同用户”，假设我们有A、B两个群，并且指令有次数限制，比如5次

如果用户在A群已经触发了5次指令，此时，如果用户到B群，还是可以继续触发该指令

因为每个群(消息来源)中的指令的状态，是独立的

### 全局交互

> any_source_any_user

假设你通过route注册了3个群

```python
BotRoute(
    groups = {
        "onebot" : [
            "group a",
            "group b",
            "group c",
        ]
    }
)
```

这时候，如果交互策略是“任意来源，任意用户”，那么，来自这三个群中任意用户的消息，都会触发当前指令

可以参考[全局复读]

## 如何设置交互策略

```python
@as_command(
    interactive_stratey="any_source_same_user"
)
class MyCommand: 
    pass
```

默认交互策略是"any_source_same_user"，也就是全局锁定同一个用户

## 跨协议关联消息来源、用户

:::warning
以下功能尚未实现
:::

`PepperBot`是一个跨社交平台的框架，有时候，我们可能有这样的需求

我同时在QQ、Telegram建了两个群，这两个群是关于相同话题的，可以理解为，我在不同的社交平台中，都提供了群聊服务

我有一些指令，这里还是用成语接龙举例子，我希望`PepperBot`能够将这两个群，视为同一个群

这样的话，两个群的成员，就可以跨社交平台，对同一个指令持续交互

这时候，我们就可以用`关联群`这样的能力

```python
bot.register_same_group({
    "onebot" : ["123456"],
    "telegram" : ["zxcvbn"],
})
```

然后配合`same_group_any_source`的交互策略，就能实现我们想要的效果

## 关联多个群=>超级大群

比如QQ中，单个群的人数有上限，有时候我们可能会开好几个群，群名一样，通过加上①、②、③这样的数字标记，来进行区分

也就是说，如果不是因为人数限制，其实这几个群可以合并成同一个群

对于这种情况，我们也可以通过`关联群`，让`PepperBot`认为这些群，是同一下消息来源

```python
bot.register_same_group({
    "onebot" :["123", "456", "789"]
})
```

## 关联用户

假设我有一个群管指令，只有管理员可以用，而我也在QQ、Telegram上同时创建了群

如果要自己实现判断逻辑的话，有点麻烦，我得先判断消息来源是哪，然后针对不同的消息平台，在自己事先建立好的映射关系中，查询是否存在对应的用户id

`PepperBot`通过了一个快捷方式，可以实现这样的效果

同时，也支持将多个同平台的小号，认为是同一个用户

```python
bot.register_same_user({
    "onebot" : ["大号", "小号1", "小号2"],
    "telegram" : ["tg的大号"]
})
```

TODO 反排
