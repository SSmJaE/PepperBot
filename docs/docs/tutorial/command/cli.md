---
title: 命令行式指令
---


:::warning

本文档正在编写中

:::

子命令
可选参数，--long -S

## 自动参数匹配 + 类型验证

从上方的例子可以看到，我们实现了参数校验的功能，参数的自动校验和解析，是通过`PatternArg`实现的

参数格式有两点要求

- 参数数量要和定义了的`PatternArg`数量一致
- 参数类型要和对应位置的`PatternArg`一致

比如这样的定义

```py
async def choose_game(self, game: str = PatternArg(), sender: CommandSender, npc : int = PatternArg()):
    sender.send_message(Text(f"你选择的是 {game} 的 {npc}，需要查询他的什么装备呢？稀有度为何？"))
```

我们定义了两个参数，第一个参数为 game，字符串类型，第二个参数为 npc，是 int 类型

可以看到，我们在统计参数的时候，跳过了`sender`这样的保留参数，只统计了默认值为`PatternArg()`的参数

用户输入参数时的顺序，应该和定义的顺序一致，比如，第一个参数因为`game`，第二个参数为`npc`

如果用户输入的参数的类型，与我们定义的不一致，比如

```py
"某游戏 某人物"
```

这里，npc 应该为 int 类型，而我们提供的是字符串"某人物"，那么，当 PepperBot 试图将字符串"某人物"转换为 int 类型时，自然会失败

在 PepperBot 中，当用户的输入不符合要求时，会自动发送格式提示，比如

```py
" <str : xxx>
```

### `initial`钩子与`PatternArg`

事实上，`initial`钩子也可以使用`PatternArg`，这样的话，我们就可以直接一步解析出参数，可以省略掉一次询问的过程，前提是，需要用户已经知道该指令的参数输入规则

```py

```

如果没能满足要求，也就是没有通过参数校验这一关，那么，指令并没有开始会话，该指令并不视为执行状态，自然，`history`中，也就没有该次，用户发送的消息

再次强调，只有成功通过参数校验的`handler`，用户发送的消息才会被注入`history`，这样实现，是为了降低心智负担，即，出现在`history`中的消息，都是满足要求的，和我们自己定义的，不出错时，逻辑的执行顺序是一致的
