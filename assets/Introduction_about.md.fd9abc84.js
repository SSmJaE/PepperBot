import{o as e,c as l,a}from"./app.14b541e2.js";const i='{"title":"为什么叫PepperBot？","description":"","frontmatter":{},"headers":[{"level":2,"title":"为什么叫PepperBot？","slug":"为什么叫pepperbot？"},{"level":2,"title":"后端","slug":"后端"},{"level":2,"title":"业务逻辑框架","slug":"业务逻辑框架"},{"level":2,"title":"PepperBot的命名规范及风格","slug":"pepperbot的命名规范及风格"}],"relativePath":"Introduction/about.md","lastUpdated":1620471902809}',t={},r=a('<h2 id="为什么叫pepperbot？"><a class="header-anchor" href="#为什么叫pepperbot？" aria-hidden="true">#</a> 为什么叫PepperBot？</h2><ul><li>我喜欢吃农家小炒肉</li></ul><h2 id="后端"><a class="header-anchor" href="#后端" aria-hidden="true">#</a> 后端</h2><ul><li>也就是负责与QQ通信的“无头QQ”，</li><li>一般建议使用go-cqhttp作为“后端”</li></ul><h2 id="业务逻辑框架"><a class="header-anchor" href="#业务逻辑框架" aria-hidden="true">#</a> 业务逻辑框架</h2><blockquote><p>为什么说PepperBot是一个业务逻辑框架？</p></blockquote><ul><li>PepperBot并没有实现与QQ通信的能力，只负责处理“业务逻辑”</li><li>PepperBot通过与后端的通信，实现了与QQ的通信</li><li>PepperBot基于OneBot协议，所以所有符合OneBot标准的“后端”，都可以使用</li></ul><h2 id="pepperbot的命名规范及风格"><a class="header-anchor" href="#pepperbot的命名规范及风格" aria-hidden="true">#</a> PepperBot的命名规范及风格</h2><blockquote><p>基本符合PEP8</p></blockquote><ul><li>变量、参数camelCase</li><li>常量全大写+下划线CONSTANT_VARIABLE</li><li>函数，方法名全小写+下划线normal_function normal_class_method</li><li>类名、文件名PascalCase AClassName</li><li>私有变量_前缀，私有方法__前缀_privateVariable,__private_method</li><li>不建议使用单行if return True if a &gt; b else False</li><li>不建议使用匿名函数 lambda x,y:x.a()+y.b()</li><li>建议使用能自说明的变量名称_privateVariable</li><li>节制使用列表推导、字典推导(单层可以用，多层嵌套的推导，建议展开) [a + b for a in range(20) for b in range(30) if a &gt; 10 and b &gt; 20]</li></ul>',10);t.render=function(a,i,t,p,o,n){return e(),l("div",null,[r])};export default t;export{i as __pageData};
