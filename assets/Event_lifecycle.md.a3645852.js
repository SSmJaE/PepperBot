import{o as e,c as a,a as r}from"./app.14b541e2.js";const s='{"title":"before","description":"","frontmatter":{},"headers":[{"level":2,"title":"before","slug":"before"},{"level":2,"title":"事件响应","slug":"事件响应"},{"level":2,"title":"after","slug":"after"}],"relativePath":"Event/lifecycle.md","lastUpdated":1620641730921}',t={},n=r('<h2 id="before"><a class="header-anchor" href="#before" aria-hidden="true">#</a> before</h2><p>return False</p><p>set context[&#39;xxxx&#39;]</p><h2 id="事件响应"><a class="header-anchor" href="#事件响应" aria-hidden="true">#</a> 事件响应</h2><p>可以在事件响应和after中接受到，向后传播</p><h2 id="after"><a class="header-anchor" href="#after" aria-hidden="true">#</a> after</h2><p>当接收到对应的消息的“副作用”时，这个应该是针对于bot，chain等的实例方法的，如group_msg, kickout is coruuteine is normal function</p><blockquote><p>通过flag实现 可以手动实现</p></blockquote><p>if sender.userId == bot.userId: if len(sendedMessage) == len(newMessage):</p><pre><code>    isSameMessageFlag = True\n    for index, segment in enumerate(sendedMessage):\n        if segment != newMessage[index]:\n            isSameMessageFlag = False\n\n    if isSameMessageFlag:\n        # 此时可以确定是同一条消息\n        pass\n</code></pre>',10);t.render=function(r,s,t,i,l,o){return e(),a("div",null,[n])};export default t;export{s as __pageData};
